<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#fafaf9">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <link rel="manifest" href="manifest.json">
  <title>Research.Pics</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;600&family=Source+Serif+4:opsz,wght@8..60,400;8..60,500;8..60,600&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --bg: #fafaf9;
      --surface: #ffffff;
      --surface-hover: #f5f5f4;
      --border: #e7e5e4;
      --text: #1c1917;
      --text-muted: #78716c;
      --accent: #292524;
      --radius: 6px;
      --transition: 150ms ease;
      --shadow-sm: 0 1px 2px rgba(0,0,0,0.04);
      --shadow: 0 2px 8px rgba(0,0,0,0.06);
    }

    html, body {
      height: 100%;
      overflow: hidden;
    }

    body {
      font-family: 'Source Serif 4', Georgia, serif;
      background: var(--bg);
      color: var(--text);
      line-height: 1.5;
      font-size: 14px;
    }

    .app {
      display: grid;
      grid-template-columns: 220px 1fr;
      height: 100vh;
      overflow: hidden;
    }

    /* Sidebar */
    .sidebar {
      background: var(--surface);
      border-right: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .logo {
      padding: 20px 16px;
      border-bottom: 1px solid var(--border);
    }

    .logo h1 {
      font-family: 'IBM Plex Mono', monospace;
      font-size: 13px;
      font-weight: 600;
      letter-spacing: -0.01em;
      color: var(--text);
    }

    .logo span {
      color: var(--text-muted);
      font-weight: 400;
    }

    .nav-section {
      padding: 12px 8px;
      flex: 1;
      overflow-y: auto;
    }

    .nav-section::-webkit-scrollbar {
      width: 4px;
    }

    .nav-section::-webkit-scrollbar-thumb {
      background: var(--border);
      border-radius: 2px;
    }

    .nav-label {
      font-family: 'IBM Plex Mono', monospace;
      font-size: 10px;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--text-muted);
      padding: 8px 10px 6px;
    }

    .nav-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      border-radius: var(--radius);
      cursor: pointer;
      transition: background var(--transition);
      font-family: 'IBM Plex Mono', monospace;
      font-size: 12px;
      color: var(--text-muted);
    }

    .nav-item:hover {
      background: var(--surface-hover);
      color: var(--text);
    }

    .nav-item.active {
      background: var(--bg);
      color: var(--text);
    }

    .nav-item svg {
      width: 14px;
      height: 14px;
      opacity: 0.6;
    }

    .nav-item.active svg {
      opacity: 1;
    }

    .nav-item .count {
      margin-left: auto;
      font-size: 10px;
      color: var(--text-muted);
    }

    .album-actions {
      display: flex;
      gap: 2px;
      margin-left: auto;
      opacity: 0;
      transition: opacity var(--transition);
    }

    .nav-item:hover .album-actions {
      opacity: 1;
    }

    .album-actions button {
      background: none;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      padding: 2px;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .album-actions button:hover {
      color: var(--text);
      background: var(--border);
    }

    .album-actions svg {
      width: 12px;
      height: 12px;
    }

    .new-album-btn {
      display: flex;
      align-items: center;
      gap: 6px;
      width: calc(100% - 16px);
      margin: 6px 8px;
      padding: 8px 10px;
      background: transparent;
      border: 1px dashed var(--border);
      border-radius: var(--radius);
      color: var(--text-muted);
      font-family: 'IBM Plex Mono', monospace;
      font-size: 12px;
      cursor: pointer;
      transition: all var(--transition);
    }

    .new-album-btn:hover {
      border-color: var(--text-muted);
      color: var(--text);
    }

    .new-album-btn svg {
      width: 12px;
      height: 12px;
    }

    .sidebar-footer {
      padding: 12px 16px;
      border-top: 1px solid var(--border);
      font-family: 'IBM Plex Mono', monospace;
      font-size: 10px;
      color: var(--text-muted);
    }

    /* Main Content */
    .main {
      display: flex;
      flex-direction: column;
      overflow: hidden;
      position: relative;
    }

    .header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 16px 20px;
      border-bottom: 1px solid var(--border);
      background: var(--surface);
      flex-shrink: 0;
    }

    .header h2 {
      font-size: 15px;
      font-weight: 500;
    }

    .header-actions {
      display: flex;
      gap: 6px;
    }

    .btn {
      display: flex;
      align-items: center;
      gap: 5px;
      padding: 6px 12px;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      color: var(--text);
      font-family: 'IBM Plex Mono', monospace;
      font-size: 11px;
      cursor: pointer;
      transition: all var(--transition);
      box-shadow: var(--shadow-sm);
    }

    .btn:hover {
      background: var(--surface-hover);
      border-color: var(--text-muted);
    }

    .btn svg {
      width: 14px;
      height: 14px;
    }

    .btn-primary {
      background: var(--text);
      color: var(--bg);
      border-color: var(--text);
    }

    .btn-primary:hover {
      background: var(--accent);
      border-color: var(--accent);
    }

    /* Drop Zone */
    .content {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
      position: relative;
    }

    .content::-webkit-scrollbar {
      width: 8px;
    }

    .content::-webkit-scrollbar-thumb {
      background: var(--border);
      border-radius: 4px;
    }

    .drop-zone {
      position: absolute;
      inset: 20px;
      border: 2px dashed var(--border);
      border-radius: 8px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 12px;
      background: var(--surface);
      opacity: 0;
      pointer-events: none;
      transition: opacity var(--transition);
      z-index: 10;
    }

    .drop-zone.active {
      opacity: 1;
      border-color: var(--text);
    }

    .drop-zone svg {
      width: 40px;
      height: 40px;
      color: var(--text-muted);
    }

    .drop-zone p {
      color: var(--text-muted);
      font-size: 13px;
    }

    /* Empty State */
    .empty-state {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100%;
      gap: 12px;
      color: var(--text-muted);
    }

    .empty-state svg {
      width: 48px;
      height: 48px;
      opacity: 0.25;
    }

    .empty-state h3 {
      font-size: 14px;
      font-weight: 500;
      color: var(--text);
    }

    .empty-state p {
      font-size: 12px;
      text-align: center;
      max-width: 260px;
    }

    .shortcut {
      display: inline-flex;
      align-items: center;
      gap: 3px;
      padding: 1px 5px;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 4px;
      font-family: 'IBM Plex Mono', monospace;
      font-size: 10px;
    }

    /* Grid */
    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
      gap: 10px;
    }

    .grid-item {
      aspect-ratio: 1;
      border-radius: var(--radius);
      overflow: hidden;
      cursor: pointer;
      position: relative;
      background: var(--border);
      transition: transform var(--transition), box-shadow var(--transition);
      box-shadow: var(--shadow-sm);
    }

    .grid-item:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow);
    }

    .grid-item.selected {
      outline: 2px solid var(--text);
      outline-offset: 2px;
    }

    .grid-item img,
    .grid-item video {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .grid-item .video-indicator {
      position: absolute;
      top: 8px;
      right: 8px;
      background: rgba(0,0,0,0.6);
      border-radius: 4px;
      padding: 4px 6px;
      display: flex;
      align-items: center;
      gap: 4px;
      font-family: 'IBM Plex Mono', monospace;
      font-size: 9px;
      color: #fff;
    }

    .grid-item .video-indicator svg {
      width: 12px;
      height: 12px;
    }

    .grid-item .overlay {
      position: absolute;
      inset: 0;
      background: linear-gradient(to top, rgba(0,0,0,0.5) 0%, transparent 50%);
      opacity: 0;
      transition: opacity var(--transition);
      display: flex;
      align-items: flex-end;
      padding: 10px;
    }

    .grid-item:hover .overlay {
      opacity: 1;
    }

    .grid-item .meta {
      font-family: 'IBM Plex Mono', monospace;
      font-size: 10px;
      color: rgba(255,255,255,0.9);
    }

    /* Lightbox */
    .lightbox {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.92);
      z-index: 100;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      pointer-events: none;
      transition: opacity 200ms ease;
    }

    .lightbox.active {
      opacity: 1;
      pointer-events: auto;
    }

    .lightbox-content {
      max-width: 90vw;
      max-height: 90vh;
      position: relative;
    }

    .lightbox-content img,
    .lightbox-content video {
      max-width: 100%;
      max-height: 90vh;
      object-fit: contain;
      border-radius: var(--radius);
    }

    .lightbox-close {
      position: absolute;
      top: 16px;
      right: 16px;
      background: rgba(255,255,255,0.1);
      backdrop-filter: blur(8px);
      border: 1px solid rgba(255,255,255,0.15);
      border-radius: 50%;
      width: 36px;
      height: 36px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      color: #fff;
      transition: all var(--transition);
      z-index: 101;
    }

    .lightbox-close:hover {
      background: rgba(255,255,255,0.2);
    }

    .lightbox-nav {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      background: rgba(255,255,255,0.1);
      backdrop-filter: blur(8px);
      border: 1px solid rgba(255,255,255,0.15);
      border-radius: 50%;
      width: 44px;
      height: 44px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      color: #fff;
      transition: all var(--transition);
      z-index: 101;
    }

    .lightbox-nav:hover {
      background: rgba(255,255,255,0.2);
    }

    .lightbox-nav.prev {
      left: 16px;
    }

    .lightbox-nav.next {
      right: 16px;
    }

    .lightbox-info {
      position: absolute;
      bottom: 16px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255,255,255,0.1);
      backdrop-filter: blur(8px);
      border: 1px solid rgba(255,255,255,0.15);
      border-radius: var(--radius);
      padding: 10px 16px;
      display: flex;
      gap: 20px;
      font-family: 'IBM Plex Mono', monospace;
      font-size: 11px;
      color: rgba(255,255,255,0.8);
      z-index: 101;
    }

    .lightbox-info span {
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .lightbox-actions {
      display: flex;
      gap: 6px;
      margin-left: 12px;
      padding-left: 12px;
      border-left: 1px solid rgba(255,255,255,0.2);
    }

    .lightbox-actions button {
      background: none;
      border: none;
      color: rgba(255,255,255,0.7);
      cursor: pointer;
      padding: 3px;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all var(--transition);
    }

    .lightbox-actions button:hover {
      color: #fff;
      background: rgba(255,255,255,0.15);
    }

    /* Modal */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 200;
      opacity: 0;
      pointer-events: none;
      transition: opacity 200ms ease;
    }

    .modal-overlay.active {
      opacity: 1;
      pointer-events: auto;
    }

    .modal {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 20px;
      width: 320px;
      max-width: 90vw;
      box-shadow: 0 16px 48px rgba(0,0,0,0.15);
    }

    .modal h3 {
      font-size: 14px;
      font-weight: 500;
      margin-bottom: 14px;
    }

    .modal input {
      width: 100%;
      padding: 8px 10px;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      color: var(--text);
      font-size: 13px;
      font-family: inherit;
      outline: none;
      transition: border-color var(--transition);
    }

    .modal input:focus {
      border-color: var(--text-muted);
    }

    .modal-actions {
      display: flex;
      gap: 6px;
      justify-content: flex-end;
      margin-top: 16px;
    }

    /* Toast */
    .toast {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%) translateY(80px);
      background: var(--text);
      color: var(--bg);
      padding: 10px 16px;
      border-radius: var(--radius);
      font-family: 'IBM Plex Mono', monospace;
      font-size: 11px;
      z-index: 300;
      transition: transform 250ms ease;
      pointer-events: none;
      box-shadow: 0 4px 16px rgba(0,0,0,0.2);
    }

    .toast.active {
      transform: translateX(-50%) translateY(0);
    }

    /* Context Menu */
    .context-menu {
      position: fixed;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 4px;
      min-width: 150px;
      z-index: 150;
      display: none;
      box-shadow: 0 8px 24px rgba(0,0,0,0.12);
    }

    .context-menu.active {
      display: block;
    }

    .context-menu-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 7px 10px;
      border-radius: 4px;
      cursor: pointer;
      font-family: 'IBM Plex Mono', monospace;
      font-size: 11px;
      color: var(--text);
      transition: background var(--transition);
    }

    .context-menu-item:hover {
      background: var(--surface-hover);
    }

    .context-menu-item svg {
      width: 13px;
      height: 13px;
      opacity: 0.6;
    }

    .context-menu-item.danger {
      color: #dc2626;
    }

    .context-divider {
      height: 1px;
      background: var(--border);
      margin: 4px 0;
    }

    /* Mobile */
    @media (max-width: 768px) {
      .app {
        grid-template-columns: 1fr;
      }

      .sidebar {
        position: fixed;
        left: -260px;
        top: 0;
        bottom: 0;
        width: 260px;
        z-index: 50;
        transition: left 250ms ease;
      }

      .sidebar.open {
        left: 0;
      }

      .sidebar-backdrop {
        position: fixed;
        inset: 0;
        background: rgba(0,0,0,0.4);
        z-index: 40;
        opacity: 0;
        pointer-events: none;
        transition: opacity 250ms ease;
      }

      .sidebar-backdrop.active {
        opacity: 1;
        pointer-events: auto;
      }

      .mobile-header {
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .menu-toggle {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 36px;
        height: 36px;
        background: var(--surface);
        border: 1px solid var(--border);
        border-radius: var(--radius);
        color: var(--text);
        cursor: pointer;
      }

      .grid {
        grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
        gap: 8px;
      }

      .lightbox-nav {
        width: 36px;
        height: 36px;
      }

      .lightbox-info {
        flex-wrap: wrap;
        justify-content: center;
        gap: 10px;
        padding: 8px 12px;
        font-size: 10px;
      }

      .lightbox-actions {
        margin-left: 0;
        padding-left: 0;
        border-left: none;
        width: 100%;
        justify-content: center;
      }
    }

    @media (min-width: 769px) {
      .menu-toggle, .sidebar-backdrop {
        display: none;
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="sidebar-backdrop" id="sidebarBackdrop"></div>
    <aside class="sidebar" id="sidebar">
      <div class="logo">
        <h1>Research<span>.Pics</span></h1>
      </div>
      <nav class="nav-section">
        <div class="nav-label">Library</div>
        <div class="nav-item active" data-view="all">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <rect x="3" y="3" width="7" height="7" rx="1"/>
            <rect x="14" y="3" width="7" height="7" rx="1"/>
            <rect x="3" y="14" width="7" height="7" rx="1"/>
            <rect x="14" y="14" width="7" height="7" rx="1"/>
          </svg>
          All Pictures
          <span class="count" id="allCount">0</span>
        </div>
        
        <div class="nav-label" style="margin-top: 16px;">Albums</div>
        <div id="albumList"></div>
        
        <button class="new-album-btn" id="newAlbumBtn">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <line x1="12" y1="5" x2="12" y2="19"/>
            <line x1="5" y1="12" x2="19" y2="12"/>
          </svg>
          New Album
        </button>
      </nav>
      <div class="sidebar-footer">
        <div style="display: flex; justify-content: space-between; align-items: center;">
          <span>Stored locally</span>
          <button id="clearStorageBtn" style="background: none; border: 1px solid var(--border); border-radius: 4px; padding: 3px 8px; font-family: inherit; font-size: 9px; color: var(--text-muted); cursor: pointer;">Clear</button>
        </div>
        <div id="storageInfo" style="margin-top: 6px; font-size: 9px; opacity: 0.7;"></div>
      </div>
    </aside>

    <main class="main">
      <header class="header">
        <div class="mobile-header">
          <button class="menu-toggle" id="menuToggle">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <line x1="3" y1="6" x2="21" y2="6"/>
              <line x1="3" y1="12" x2="21" y2="12"/>
              <line x1="3" y1="18" x2="21" y2="18"/>
            </svg>
          </button>
          <h2 id="viewTitle">All Pictures</h2>
        </div>
        <div class="header-actions">
          <button class="btn" id="selectAllBtn" style="display: none;">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <rect x="3" y="3" width="18" height="18" rx="2"/>
              <polyline points="9 11 12 14 22 4"/>
            </svg>
            All
          </button>
          <button class="btn" id="downloadSelectedBtn" style="display: none;">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
              <polyline points="7 10 12 15 17 10"/>
              <line x1="12" y1="15" x2="12" y2="3"/>
            </svg>
            Download (<span id="selectedCount">0</span>)
          </button>
          <button class="btn" id="selectBtn">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <polyline points="9 11 12 14 22 4"/>
              <path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"/>
            </svg>
            Select
          </button>
          <label class="btn btn-primary">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
              <polyline points="17 8 12 3 7 8"/>
              <line x1="12" y1="3" x2="12" y2="15"/>
            </svg>
            Add Media
            <input type="file" id="fileInput" multiple accept="image/*,video/*" hidden>
          </label>
        </div>
      </header>

      <div class="content" id="content">
        <div class="drop-zone" id="dropZone">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
            <polyline points="17 8 12 3 7 8"/>
            <line x1="12" y1="3" x2="12" y2="15"/>
          </svg>
          <p>Drop files here</p>
        </div>

        <div id="emptyState" class="empty-state">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <rect x="3" y="3" width="18" height="18" rx="2"/>
            <circle cx="8.5" cy="8.5" r="1.5"/>
            <polyline points="21 15 16 10 5 21"/>
          </svg>
          <h3>No media yet</h3>
          <p>
            Drag & drop images or videos here, paste with
            <span class="shortcut">âŒ˜V</span>, or click Add Media
          </p>
        </div>

        <div class="grid" id="grid"></div>
      </div>
    </main>
  </div>

  <!-- Lightbox -->
  <div class="lightbox" id="lightbox">
    <button class="lightbox-close" id="lightboxClose">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <line x1="18" y1="6" x2="6" y2="18"/>
        <line x1="6" y1="6" x2="18" y2="18"/>
      </svg>
    </button>
    <button class="lightbox-nav prev" id="lightboxPrev">
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <polyline points="15 18 9 12 15 6"/>
      </svg>
    </button>
    <div class="lightbox-content">
      <img id="lightboxImg" src="" alt="">
      <video id="lightboxVideo" controls style="display: none;"></video>
    </div>
    <button class="lightbox-nav next" id="lightboxNext">
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <polyline points="9 18 15 12 9 6"/>
      </svg>
    </button>
    <div class="lightbox-info">
      <span id="lightboxCounter">1 / 10</span>
      <span id="lightboxSize"></span>
      <span id="lightboxDate"></span>
      <div class="lightbox-actions">
        <button id="lightboxDownload" title="Download">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
            <polyline points="7 10 12 15 17 10"/>
            <line x1="12" y1="15" x2="12" y2="3"/>
          </svg>
        </button>
        <button id="lightboxAddToAlbum" title="Add to Album">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/>
            <line x1="12" y1="11" x2="12" y2="17"/>
            <line x1="9" y1="14" x2="15" y2="14"/>
          </svg>
        </button>
        <button id="lightboxDelete" title="Delete">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="3 6 5 6 21 6"/>
            <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
          </svg>
        </button>
      </div>
    </div>
  </div>

  <!-- New Album Modal -->
  <div class="modal-overlay" id="newAlbumModal">
    <div class="modal">
      <h3 id="modalTitle">Create New Album</h3>
      <input type="text" id="albumNameInput" placeholder="Album name">
      <div class="modal-actions">
        <button class="btn" id="cancelAlbumBtn">Cancel</button>
        <button class="btn btn-primary" id="saveAlbumBtn">Create</button>
      </div>
    </div>
  </div>

  <!-- Add to Album Modal -->
  <div class="modal-overlay" id="addToAlbumModal">
    <div class="modal">
      <h3>Add to Album</h3>
      <div id="albumSelectList" style="max-height: 200px; overflow-y: auto;"></div>
      <div class="modal-actions">
        <button class="btn" id="cancelAddToAlbumBtn">Cancel</button>
      </div>
    </div>
  </div>

  <!-- Context Menu -->
  <div class="context-menu" id="contextMenu">
    <div class="context-menu-item" id="ctxAddToAlbum">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/>
        <line x1="12" y1="11" x2="12" y2="17"/>
        <line x1="9" y1="14" x2="15" y2="14"/>
      </svg>
      Add to Album
    </div>
    <div class="context-menu-item" id="ctxDownload">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
        <polyline points="7 10 12 15 17 10"/>
        <line x1="12" y1="15" x2="12" y2="3"/>
      </svg>
      Download
    </div>
    <div class="context-divider"></div>
    <div class="context-menu-item" id="ctxRemoveFromAlbum" style="display: none;">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/>
        <line x1="9" y1="14" x2="15" y2="14"/>
      </svg>
      Remove from Album
    </div>
    <div class="context-menu-item danger" id="ctxDelete">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <polyline points="3 6 5 6 21 6"/>
        <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
      </svg>
      Delete
    </div>
  </div>

  <!-- Toast -->
  <div class="toast" id="toast"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script>
    // Storage abstraction - OPFS with IndexedDB fallback
    const DB_NAME = 'researchpics';
    const DB_VERSION = 2;
    let db;
    let useOPFS = false;
    let opfsRoot = null;

    // Check OPFS support and initialize
    async function initStorage() {
      // Try OPFS first
      try {
        if ('storage' in navigator && 'getDirectory' in navigator.storage) {
          opfsRoot = await navigator.storage.getDirectory();
          useOPFS = true;
          console.log('Using OPFS for file storage');
        }
      } catch (e) {
        console.log('OPFS not available, using IndexedDB fallback');
      }

      // Initialize IndexedDB for metadata (and blob fallback)
      await new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);

        request.onerror = () => reject(request.error);
        request.onsuccess = () => {
          db = request.result;
          resolve(db);
        };

        request.onupgradeneeded = (e) => {
          const database = e.target.result;

          if (!database.objectStoreNames.contains('pictures')) {
            const pictureStore = database.createObjectStore('pictures', { keyPath: 'id' });
            pictureStore.createIndex('createdAt', 'createdAt', { unique: false });
          }

          if (!database.objectStoreNames.contains('albums')) {
            database.createObjectStore('albums', { keyPath: 'id' });
          }

          // For IndexedDB fallback - store blobs separately
          if (!database.objectStoreNames.contains('blobs')) {
            database.createObjectStore('blobs', { keyPath: 'id' });
          }
        };
      });

      // Migrate old data format (base64 data URLs) to new format (blobs)
      await migrateOldData();
    }

    // Migrate old pictures that have inline data URLs to new blob storage
    async function migrateOldData() {
      const pics = await getAllPictures();
      let migrated = 0;

      for (const pic of pics) {
        // Old format had 'data' property with base64 data URL
        if (pic.data && typeof pic.data === 'string' && pic.data.startsWith('data:')) {
          try {
            // Convert data URL to blob
            const response = await fetch(pic.data);
            const blob = await response.blob();

            // Save blob to new storage
            await saveFile(pic.id, blob);

            // Update picture metadata (remove old data property)
            const updatedPic = { ...pic };
            delete updatedPic.data;
            updatedPic.isVideo = pic.type?.startsWith('video/') || false;
            await updatePicture(updatedPic);

            migrated++;
          } catch (e) {
            console.warn('Failed to migrate picture:', pic.id, e);
          }
        }
      }

      if (migrated > 0) {
        console.log(`Migrated ${migrated} pictures to new storage format`);
      }
    }

    // OPFS file operations
    async function saveFileToOPFS(id, blob) {
      const fileHandle = await opfsRoot.getFileHandle(id, { create: true });
      const writable = await fileHandle.createWritable();
      await writable.write(blob);
      await writable.close();
    }

    async function getFileFromOPFS(id) {
      try {
        const fileHandle = await opfsRoot.getFileHandle(id);
        return await fileHandle.getFile();
      } catch {
        return null;
      }
    }

    async function deleteFileFromOPFS(id) {
      try {
        await opfsRoot.removeEntry(id);
      } catch {
        // File might not exist
      }
    }

    // IndexedDB blob operations (fallback)
    async function saveBlobToIDB(id, blob) {
      return new Promise((resolve, reject) => {
        const tx = db.transaction('blobs', 'readwrite');
        const store = tx.objectStore('blobs');
        store.put({ id, blob });
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
      });
    }

    async function getBlobFromIDB(id) {
      return new Promise((resolve, reject) => {
        const tx = db.transaction('blobs', 'readonly');
        const store = tx.objectStore('blobs');
        const request = store.get(id);
        request.onsuccess = () => resolve(request.result?.blob || null);
        request.onerror = () => reject(request.error);
      });
    }

    async function deleteBlobFromIDB(id) {
      return new Promise((resolve, reject) => {
        const tx = db.transaction('blobs', 'readwrite');
        const store = tx.objectStore('blobs');
        store.delete(id);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
      });
    }

    // Unified file operations
    async function saveFile(id, blob) {
      if (useOPFS) {
        await saveFileToOPFS(id, blob);
      } else {
        await saveBlobToIDB(id, blob);
      }
    }

    async function getFile(id) {
      if (useOPFS) {
        return await getFileFromOPFS(id);
      } else {
        return await getBlobFromIDB(id);
      }
    }

    async function deleteFile(id) {
      if (useOPFS) {
        await deleteFileFromOPFS(id);
      } else {
        await deleteBlobFromIDB(id);
      }
    }

    // Object URL management to prevent memory leaks
    const objectURLs = new Map();

    function createObjectURL(id, blob) {
      if (objectURLs.has(id)) {
        return objectURLs.get(id);
      }
      const url = URL.createObjectURL(blob);
      objectURLs.set(id, url);
      return url;
    }

    function revokeObjectURL(id) {
      if (objectURLs.has(id)) {
        URL.revokeObjectURL(objectURLs.get(id));
        objectURLs.delete(id);
      }
    }

    function revokeAllObjectURLs() {
      for (const url of objectURLs.values()) {
        URL.revokeObjectURL(url);
      }
      objectURLs.clear();
    }

    // Picture operations
    async function savePicture(file) {
      const id = `pic_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      const isVideo = file.type.startsWith('video/');

      // Save the file blob
      await saveFile(id, file);

      // Save metadata to IndexedDB
      const picture = {
        id,
        name: file.name,
        type: file.type,
        size: file.size,
        isVideo,
        createdAt: Date.now(),
        albums: []
      };

      return new Promise((resolve, reject) => {
        const tx = db.transaction('pictures', 'readwrite');
        const store = tx.objectStore('pictures');
        store.put(picture);
        tx.oncomplete = () => resolve(picture);
        tx.onerror = () => reject(tx.error);
      });
    }

    async function getAllPictures() {
      return new Promise((resolve, reject) => {
        const tx = db.transaction('pictures', 'readonly');
        const store = tx.objectStore('pictures');
        const request = store.getAll();

        request.onsuccess = () => {
          const pics = request.result.sort((a, b) => b.createdAt - a.createdAt);
          resolve(pics);
        };
        request.onerror = () => reject(request.error);
      });
    }

    async function getPicture(id) {
      return new Promise((resolve, reject) => {
        const tx = db.transaction('pictures', 'readonly');
        const store = tx.objectStore('pictures');
        const request = store.get(id);

        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
      });
    }

    async function getPictureWithBlob(id) {
      const pic = await getPicture(id);
      if (!pic) return null;
      const blob = await getFile(id);
      return { ...pic, blob };
    }

    async function updatePicture(picture) {
      return new Promise((resolve, reject) => {
        const tx = db.transaction('pictures', 'readwrite');
        const store = tx.objectStore('pictures');
        store.put(picture);

        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
      });
    }

    async function deletePicture(id) {
      // Delete file
      await deleteFile(id);
      revokeObjectURL(id);

      // Delete metadata
      return new Promise((resolve, reject) => {
        const tx = db.transaction('pictures', 'readwrite');
        const store = tx.objectStore('pictures');
        store.delete(id);

        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
      });
    }

    // Album operations
    async function createAlbum(name) {
      return new Promise((resolve, reject) => {
        const id = `album_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        const album = { id, name, createdAt: Date.now() };

        const tx = db.transaction('albums', 'readwrite');
        const store = tx.objectStore('albums');
        store.put(album);

        tx.oncomplete = () => resolve(album);
        tx.onerror = () => reject(tx.error);
      });
    }

    async function getAllAlbums() {
      return new Promise((resolve, reject) => {
        const tx = db.transaction('albums', 'readonly');
        const store = tx.objectStore('albums');
        const request = store.getAll();

        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
      });
    }

    async function updateAlbum(album) {
      return new Promise((resolve, reject) => {
        const tx = db.transaction('albums', 'readwrite');
        const store = tx.objectStore('albums');
        store.put(album);

        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
      });
    }

    async function deleteAlbum(id) {
      // Remove album reference from all pictures
      const pictures = await getAllPictures();
      for (const pic of pictures) {
        if (pic.albums.includes(id)) {
          pic.albums = pic.albums.filter(a => a !== id);
          await updatePicture(pic);
        }
      }

      return new Promise((resolve, reject) => {
        const tx = db.transaction('albums', 'readwrite');
        const store = tx.objectStore('albums');
        store.delete(id);

        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
      });
    }

    async function getAlbumPictures(albumId) {
      const pictures = await getAllPictures();
      return pictures.filter(p => p.albums.includes(albumId));
    }

    // Clear all storage
    async function clearAllStorage() {
      // Clear OPFS
      if (useOPFS && opfsRoot) {
        for await (const [name] of opfsRoot) {
          await opfsRoot.removeEntry(name);
        }
      }

      // Clear IndexedDB
      const tx = db.transaction(['pictures', 'albums', 'blobs'], 'readwrite');
      tx.objectStore('pictures').clear();
      tx.objectStore('albums').clear();
      tx.objectStore('blobs').clear();

      // Clear object URLs
      revokeAllObjectURLs();

      return new Promise((resolve, reject) => {
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
      });
    }

    // Get storage usage info
    async function getStorageInfo() {
      const pics = await getAllPictures();
      const totalSize = pics.reduce((sum, p) => sum + p.size, 0);
      const videoCount = pics.filter(p => p.isVideo).length;
      const imageCount = pics.length - videoCount;
      return { totalSize, imageCount, videoCount, totalCount: pics.length };
    }

    // UI State
    let currentView = 'all';
    let currentAlbumId = null;
    let pictures = [];
    let albums = [];
    let selectedPictures = new Set();
    let isSelectMode = false;
    let lightboxIndex = 0;
    let contextPictureId = null;
    let editingAlbumId = null;

    // DOM Elements
    const grid = document.getElementById('grid');
    const emptyState = document.getElementById('emptyState');
    const allCount = document.getElementById('allCount');
    const albumList = document.getElementById('albumList');
    const viewTitle = document.getElementById('viewTitle');
    const dropZone = document.getElementById('dropZone');
    const fileInput = document.getElementById('fileInput');
    const lightbox = document.getElementById('lightbox');
    const lightboxImg = document.getElementById('lightboxImg');
    const lightboxCounter = document.getElementById('lightboxCounter');
    const lightboxSize = document.getElementById('lightboxSize');
    const lightboxDate = document.getElementById('lightboxDate');
    const newAlbumModal = document.getElementById('newAlbumModal');
    const addToAlbumModal = document.getElementById('addToAlbumModal');
    const albumNameInput = document.getElementById('albumNameInput');
    const modalTitle = document.getElementById('modalTitle');
    const saveAlbumBtn = document.getElementById('saveAlbumBtn');
    const contextMenu = document.getElementById('contextMenu');
    const toast = document.getElementById('toast');
    const sidebar = document.getElementById('sidebar');
    const sidebarBackdrop = document.getElementById('sidebarBackdrop');
    const selectBtn = document.getElementById('selectBtn');
    const selectAllBtn = document.getElementById('selectAllBtn');
    const downloadSelectedBtn = document.getElementById('downloadSelectedBtn');
    const selectedCountEl = document.getElementById('selectedCount');

    // Update selection UI
    function updateSelectionUI() {
      const count = selectedPictures.size;
      selectedCountEl.textContent = count;
      downloadSelectedBtn.style.display = count > 0 ? 'flex' : 'none';
    }

    // Download multiple pictures as zip
    async function downloadSelectedAsZip() {
      if (selectedPictures.size === 0) return;

      showToast('Preparing download...');

      const zip = new JSZip();
      const folder = zip.folder('researchpics');

      let index = 0;
      for (const picId of selectedPictures) {
        const pic = await getPictureWithBlob(picId);
        if (pic && pic.blob) {
          const ext = pic.type.split('/')[1] || 'png';
          const filename = pic.name || `media_${index + 1}.${ext}`;
          folder.file(filename, pic.blob);
          index++;
        }
      }

      const blob = await zip.generateAsync({ type: 'blob' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `researchpics_${Date.now()}.zip`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);

      showToast(`Downloaded ${index} file${index !== 1 ? 's' : ''}`);
    }

    // Toast
    function showToast(message) {
      toast.textContent = message;
      toast.classList.add('active');
      setTimeout(() => toast.classList.remove('active'), 2000);
    }

    // Format bytes
    function formatBytes(bytes) {
      if (bytes < 1024) return bytes + ' B';
      if (bytes < 1048576) return (bytes / 1024).toFixed(1) + ' KB';
      return (bytes / 1048576).toFixed(1) + ' MB';
    }

    // Format date
    function formatDate(timestamp) {
      return new Date(timestamp).toLocaleDateString('en-US', {
        month: 'short',
        day: 'numeric',
        year: 'numeric'
      });
    }

    // Render grid - uses DOM methods to avoid string length issues with many large files
    async function renderGrid() {
      let displayPictures;

      if (currentView === 'all') {
        displayPictures = await getAllPictures();
      } else {
        displayPictures = await getAlbumPictures(currentAlbumId);
      }

      pictures = displayPictures;

      if (pictures.length === 0) {
        grid.innerHTML = '';
        emptyState.style.display = 'flex';
        updateStorageInfo();
        return;
      }

      emptyState.style.display = 'none';

      // Clear grid and build DOM elements individually
      grid.innerHTML = '';
      const fragment = document.createDocumentFragment();

      for (let index = 0; index < pictures.length; index++) {
        const pic = pictures[index];
        const item = document.createElement('div');
        item.className = 'grid-item' + (selectedPictures.has(pic.id) ? ' selected' : '');
        item.dataset.id = pic.id;
        item.dataset.index = index;

        // Create media element (image or video)
        if (pic.isVideo) {
          const video = document.createElement('video');
          video.muted = true;
          video.preload = 'metadata';
          // Load blob and create object URL
          loadMediaElement(video, pic.id);

          // Video indicator
          const indicator = document.createElement('div');
          indicator.className = 'video-indicator';
          indicator.innerHTML = `<svg viewBox="0 0 24 24" fill="currentColor"><polygon points="5 3 19 12 5 21 5 3"/></svg>`;
          item.appendChild(video);
          item.appendChild(indicator);
        } else {
          const img = document.createElement('img');
          img.alt = pic.name || '';
          img.loading = 'lazy';
          // Load blob and create object URL
          loadMediaElement(img, pic.id);
          item.appendChild(img);
        }

        // Overlay
        const overlay = document.createElement('div');
        overlay.className = 'overlay';
        const meta = document.createElement('div');
        meta.className = 'meta';
        meta.textContent = formatBytes(pic.size);
        overlay.appendChild(meta);
        item.appendChild(overlay);

        fragment.appendChild(item);
      }

      grid.appendChild(fragment);

      // Update count
      const allPics = await getAllPictures();
      allCount.textContent = allPics.length;
      updateStorageInfo();
    }

    // Load media element with object URL from blob storage
    async function loadMediaElement(element, id) {
      const blob = await getFile(id);
      if (blob) {
        const url = createObjectURL(id, blob);
        element.src = url;
      }
    }

    // Update storage info display
    async function updateStorageInfo() {
      const info = await getStorageInfo();
      const storageEl = document.getElementById('storageInfo');
      if (storageEl) {
        let text = formatBytes(info.totalSize);
        if (info.videoCount > 0) {
          text += ` (${info.imageCount} img, ${info.videoCount} vid)`;
        }
        storageEl.textContent = text;
      }
    }

    // Render albums
    async function renderAlbums() {
      albums = await getAllAlbums();
      
      albumList.innerHTML = albums.map(album => `
        <div class="nav-item ${currentView === 'album' && currentAlbumId === album.id ? 'active' : ''}" 
             data-album-id="${album.id}">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/>
          </svg>
          ${album.name}
          <div class="album-actions">
            <button class="edit-album" data-album-id="${album.id}">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/>
                <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
              </svg>
            </button>
            <button class="delete-album" data-album-id="${album.id}">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="3 6 5 6 21 6"/>
                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
              </svg>
            </button>
          </div>
        </div>
      `).join('');
    }

    // Switch view
    function switchView(view, albumId = null) {
      currentView = view;
      currentAlbumId = albumId;
      selectedPictures.clear();
      isSelectMode = false;
      selectBtn.innerHTML = `
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <polyline points="9 11 12 14 22 4"/>
          <path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"/>
        </svg>
        Select
      `;
      
      document.querySelectorAll('.nav-item').forEach(item => {
        item.classList.remove('active');
      });
      
      if (view === 'all') {
        viewTitle.textContent = 'All Pictures';
        document.querySelector('[data-view="all"]').classList.add('active');
      } else {
        const album = albums.find(a => a.id === albumId);
        viewTitle.textContent = album ? album.name : 'Album';
        document.querySelector(`[data-album-id="${albumId}"]`)?.classList.add('active');
      }
      
      renderGrid();
      closeSidebar();
    }

    // Handle file upload
    async function handleFiles(files) {
      const mediaFiles = Array.from(files).filter(f =>
        f.type.startsWith('image/') || f.type.startsWith('video/')
      );

      if (mediaFiles.length === 0) {
        showToast('No valid media files found');
        return;
      }

      showToast(`Adding ${mediaFiles.length} file${mediaFiles.length > 1 ? 's' : ''}...`);

      for (const file of mediaFiles) {
        const pic = await savePicture(file);

        // If in album view, add to current album
        if (currentView === 'album' && currentAlbumId) {
          pic.albums.push(currentAlbumId);
          await updatePicture(pic);
        }
      }

      showToast(`Added ${mediaFiles.length} file${mediaFiles.length > 1 ? 's' : ''}`);
      renderGrid();
      renderAlbums();
    }

    // Lightbox
    const lightboxVideo = document.getElementById('lightboxVideo');

    function openLightbox(index) {
      lightboxIndex = index;
      updateLightbox();
      lightbox.classList.add('active');
      document.body.style.overflow = 'hidden';
    }

    function closeLightbox() {
      lightbox.classList.remove('active');
      document.body.style.overflow = '';
      // Pause video if playing
      lightboxVideo.pause();
      lightboxVideo.src = '';
    }

    async function updateLightbox() {
      const pic = pictures[lightboxIndex];
      if (!pic) return;

      // Get blob and create/reuse object URL
      const blob = await getFile(pic.id);
      const url = blob ? createObjectURL(pic.id, blob) : '';

      // Show appropriate media element
      if (pic.isVideo) {
        lightboxImg.style.display = 'none';
        lightboxVideo.style.display = 'block';
        lightboxVideo.src = url;
      } else {
        lightboxVideo.style.display = 'none';
        lightboxVideo.pause();
        lightboxImg.style.display = 'block';
        lightboxImg.src = url;
      }

      lightboxCounter.textContent = `${lightboxIndex + 1} / ${pictures.length}`;
      lightboxSize.textContent = formatBytes(pic.size);
      lightboxDate.textContent = formatDate(pic.createdAt);
    }

    function lightboxPrev() {
      lightboxVideo.pause();
      lightboxIndex = (lightboxIndex - 1 + pictures.length) % pictures.length;
      updateLightbox();
    }

    function lightboxNext() {
      lightboxVideo.pause();
      lightboxIndex = (lightboxIndex + 1) % pictures.length;
      updateLightbox();
    }

    // Download picture
    async function downloadPicture(pic) {
      const blob = await getFile(pic.id);
      if (!blob) return;

      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = pic.name || (pic.isVideo ? 'video.mp4' : 'image.png');
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    // Mobile sidebar
    function openSidebar() {
      sidebar.classList.add('open');
      sidebarBackdrop.classList.add('active');
    }

    function closeSidebar() {
      sidebar.classList.remove('open');
      sidebarBackdrop.classList.remove('active');
    }

    // Render album select list
    function renderAlbumSelectList(pictureIds) {
      const albumSelectList = document.getElementById('albumSelectList');
      albumSelectList.innerHTML = albums.map(album => `
        <div class="nav-item" data-select-album="${album.id}">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/>
          </svg>
          ${album.name}
        </div>
      `).join('') || '<p style="padding: 12px; color: var(--text-muted); font-size: 13px;">No albums yet. Create one first.</p>';
      
      // Add click handlers
      albumSelectList.querySelectorAll('[data-select-album]').forEach(item => {
        item.addEventListener('click', async () => {
          const albumId = item.dataset.selectAlbum;
          
          for (const picId of pictureIds) {
            const pic = await getPicture(picId);
            if (pic && !pic.albums.includes(albumId)) {
              pic.albums.push(albumId);
              await updatePicture(pic);
            }
          }
          
          addToAlbumModal.classList.remove('active');
          showToast(`Added to album`);
          renderGrid();
        });
      });
    }

    // Event Listeners
    
    // File input
    fileInput.addEventListener('change', (e) => {
      handleFiles(e.target.files);
      e.target.value = '';
    });

    // Drag and drop
    document.addEventListener('dragover', (e) => {
      e.preventDefault();
      dropZone.classList.add('active');
    });

    document.addEventListener('dragleave', (e) => {
      if (!e.relatedTarget || !document.body.contains(e.relatedTarget)) {
        dropZone.classList.remove('active');
      }
    });

    document.addEventListener('drop', (e) => {
      e.preventDefault();
      dropZone.classList.remove('active');
      handleFiles(e.dataTransfer.files);
    });

    // Paste
    document.addEventListener('paste', async (e) => {
      const items = e.clipboardData?.items;
      if (!items) return;

      const files = [];
      for (const item of items) {
        if (item.type.startsWith('image/') || item.type.startsWith('video/')) {
          const file = item.getAsFile();
          if (file) files.push(file);
        }
      }

      if (files.length > 0) {
        handleFiles(files);
      }
    });

    // Grid clicks
    grid.addEventListener('click', (e) => {
      const item = e.target.closest('.grid-item');
      if (!item) return;
      
      const id = item.dataset.id;
      const index = parseInt(item.dataset.index);
      
      if (isSelectMode) {
        if (selectedPictures.has(id)) {
          selectedPictures.delete(id);
          item.classList.remove('selected');
        } else {
          selectedPictures.add(id);
          item.classList.add('selected');
        }
        updateSelectionUI();
      } else {
        openLightbox(index);
      }
    });

    // Grid right-click
    grid.addEventListener('contextmenu', (e) => {
      e.preventDefault();
      const item = e.target.closest('.grid-item');
      if (!item) return;
      
      contextPictureId = item.dataset.id;
      
      // Show/hide remove from album option
      const removeOption = document.getElementById('ctxRemoveFromAlbum');
      if (currentView === 'album') {
        removeOption.style.display = 'flex';
      } else {
        removeOption.style.display = 'none';
      }
      
      contextMenu.style.left = e.pageX + 'px';
      contextMenu.style.top = e.pageY + 'px';
      contextMenu.classList.add('active');
    });

    // Close context menu
    document.addEventListener('click', () => {
      contextMenu.classList.remove('active');
    });

    // Context menu actions
    document.getElementById('ctxAddToAlbum').addEventListener('click', async () => {
      renderAlbumSelectList([contextPictureId]);
      addToAlbumModal.classList.add('active');
    });

    document.getElementById('ctxDownload').addEventListener('click', async () => {
      const pic = await getPicture(contextPictureId);
      if (pic) downloadPicture(pic);
    });

    document.getElementById('ctxRemoveFromAlbum').addEventListener('click', async () => {
      const pic = await getPicture(contextPictureId);
      if (pic && currentAlbumId) {
        pic.albums = pic.albums.filter(a => a !== currentAlbumId);
        await updatePicture(pic);
        showToast('Removed from album');
        renderGrid();
      }
    });

    document.getElementById('ctxDelete').addEventListener('click', async () => {
      await deletePicture(contextPictureId);
      showToast('Picture deleted');
      renderGrid();
      renderAlbums();
    });

    // Select mode
    selectBtn.addEventListener('click', () => {
      isSelectMode = !isSelectMode;
      selectedPictures.clear();
      updateSelectionUI();
      
      if (isSelectMode) {
        selectAllBtn.style.display = 'flex';
        selectBtn.innerHTML = `
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <line x1="18" y1="6" x2="6" y2="18"/>
            <line x1="6" y1="6" x2="18" y2="18"/>
          </svg>
          Cancel
        `;
      } else {
        selectAllBtn.style.display = 'none';
        selectBtn.innerHTML = `
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="9 11 12 14 22 4"/>
            <path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"/>
          </svg>
          Select
        `;
      }
      
      renderGrid();
    });

    // Select all
    selectAllBtn.addEventListener('click', () => {
      if (selectedPictures.size === pictures.length) {
        // Deselect all
        selectedPictures.clear();
        document.querySelectorAll('.grid-item').forEach(item => {
          item.classList.remove('selected');
        });
      } else {
        // Select all
        pictures.forEach(pic => selectedPictures.add(pic.id));
        document.querySelectorAll('.grid-item').forEach(item => {
          item.classList.add('selected');
        });
      }
      updateSelectionUI();
    });

    // Download selected
    downloadSelectedBtn.addEventListener('click', downloadSelectedAsZip);

    // Lightbox controls
    document.getElementById('lightboxClose').addEventListener('click', closeLightbox);
    document.getElementById('lightboxPrev').addEventListener('click', lightboxPrev);
    document.getElementById('lightboxNext').addEventListener('click', lightboxNext);

    document.getElementById('lightboxDownload').addEventListener('click', () => {
      downloadPicture(pictures[lightboxIndex]);
    });

    document.getElementById('lightboxAddToAlbum').addEventListener('click', () => {
      renderAlbumSelectList([pictures[lightboxIndex].id]);
      addToAlbumModal.classList.add('active');
    });

    document.getElementById('lightboxDelete').addEventListener('click', async () => {
      await deletePicture(pictures[lightboxIndex].id);
      closeLightbox();
      showToast('Picture deleted');
      renderGrid();
      renderAlbums();
    });

    lightbox.addEventListener('click', (e) => {
      if (e.target === lightbox) closeLightbox();
    });

    // Keyboard navigation
    document.addEventListener('keydown', (e) => {
      if (lightbox.classList.contains('active')) {
        if (e.key === 'Escape') closeLightbox();
        if (e.key === 'ArrowLeft') lightboxPrev();
        if (e.key === 'ArrowRight') lightboxNext();
      }
    });

    // Nav clicks
    document.querySelector('[data-view="all"]').addEventListener('click', () => {
      switchView('all');
    });

    albumList.addEventListener('click', (e) => {
      const albumItem = e.target.closest('.nav-item[data-album-id]');
      const editBtn = e.target.closest('.edit-album');
      const deleteBtn = e.target.closest('.delete-album');
      
      if (editBtn) {
        e.stopPropagation();
        const albumId = editBtn.dataset.albumId;
        const album = albums.find(a => a.id === albumId);
        if (album) {
          editingAlbumId = albumId;
          modalTitle.textContent = 'Rename Album';
          saveAlbumBtn.textContent = 'Save';
          albumNameInput.value = album.name;
          newAlbumModal.classList.add('active');
          albumNameInput.focus();
        }
      } else if (deleteBtn) {
        e.stopPropagation();
        const albumId = deleteBtn.dataset.albumId;
        if (confirm('Delete this album? Pictures will not be deleted.')) {
          deleteAlbum(albumId).then(() => {
            if (currentAlbumId === albumId) {
              switchView('all');
            }
            renderAlbums();
            showToast('Album deleted');
          });
        }
      } else if (albumItem) {
        switchView('album', albumItem.dataset.albumId);
      }
    });

    // New album
    document.getElementById('newAlbumBtn').addEventListener('click', () => {
      editingAlbumId = null;
      modalTitle.textContent = 'Create New Album';
      saveAlbumBtn.textContent = 'Create';
      albumNameInput.value = '';
      newAlbumModal.classList.add('active');
      albumNameInput.focus();
    });

    document.getElementById('cancelAlbumBtn').addEventListener('click', () => {
      newAlbumModal.classList.remove('active');
    });

    saveAlbumBtn.addEventListener('click', async () => {
      const name = albumNameInput.value.trim();
      if (!name) return;
      
      if (editingAlbumId) {
        const album = albums.find(a => a.id === editingAlbumId);
        if (album) {
          album.name = name;
          await updateAlbum(album);
          showToast('Album renamed');
        }
      } else {
        await createAlbum(name);
        showToast('Album created');
      }
      
      newAlbumModal.classList.remove('active');
      renderAlbums();
      
      if (currentAlbumId === editingAlbumId) {
        viewTitle.textContent = name;
      }
    });

    albumNameInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') saveAlbumBtn.click();
      if (e.key === 'Escape') newAlbumModal.classList.remove('active');
    });

    // Add to album modal
    document.getElementById('cancelAddToAlbumBtn').addEventListener('click', () => {
      addToAlbumModal.classList.remove('active');
    });

    // Mobile menu
    document.getElementById('menuToggle').addEventListener('click', openSidebar);
    sidebarBackdrop.addEventListener('click', closeSidebar);

    // Close modals on overlay click
    newAlbumModal.addEventListener('click', (e) => {
      if (e.target === newAlbumModal) newAlbumModal.classList.remove('active');
    });

    addToAlbumModal.addEventListener('click', (e) => {
      if (e.target === addToAlbumModal) addToAlbumModal.classList.remove('active');
    });

    // Clear storage button
    document.getElementById('clearStorageBtn').addEventListener('click', async () => {
      const info = await getStorageInfo();
      if (info.totalCount === 0) {
        showToast('Storage is already empty');
        return;
      }

      if (confirm(`Delete all ${info.totalCount} files (${formatBytes(info.totalSize)})? This cannot be undone.`)) {
        await clearAllStorage();
        showToast('Storage cleared');
        switchView('all');
        renderGrid();
        renderAlbums();
      }
    });

    // Service Worker - auto-updates and reloads when new version available
    if ('serviceWorker' in navigator) {
      let refreshing = false;
      navigator.serviceWorker.addEventListener('controllerchange', () => {
        if (!refreshing) {
          refreshing = true;
          window.location.reload();
        }
      });
      navigator.serviceWorker.register('sw.js').catch(() => {});
    }

    // Init
    initStorage().then(() => {
      renderGrid();
      renderAlbums();
    }).catch(err => {
      console.error('Failed to initialize storage:', err);
      showToast('Failed to initialize storage');
    });
  </script>
</body>
</html>
